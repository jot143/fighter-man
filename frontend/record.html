<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">
    <title>Stage 1 - Training Sessions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            background: #0a0a0a;
            font-family: "Montserrat", sans-serif;
        }

        .recording-pulse {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sensor-bar {
            transition: height 0.1s ease-out;
        }

        .session-item:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .session-item.active {
            background: rgba(59, 130, 246, 0.2);
            border-left: 3px solid #3b82f6;
        }
    </style>
    <script src="js/activityDetector.js"></script>
</head>

<body class="text-gray-200">
    <div class="flex flex-col h-screen">
        <!-- Header -->
        <div class="bg-black border-b border-gray-800 px-6 py-4 flex items-center justify-between">
            <div>
                <h1 class="text-xl font-semibold">Stage 1: Training Sessions</h1>
                <p class="text-sm text-gray-500">Record single-activity sessions for pattern analysis</p>
            </div>
            <div class="flex items-center gap-4">
                <!-- Connection Status -->
                <div id="connectionStatus" class="flex items-center gap-2 text-sm">
                    <span class="w-2 h-2 rounded-full bg-gray-500"></span>
                    <span class="text-gray-500">Disconnected</span>
                </div>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex flex-1 overflow-hidden">
            <!-- Left Sidebar - Sessions List -->
            <div class="w-72 bg-black border-r border-gray-800 flex flex-col">
                <!-- New Session Controls -->
                <div class="p-4 border-b border-gray-800">
                    <div class="mb-3">
                        <label class="text-xs text-gray-500 mb-1 block">Session Name (optional)</label>
                        <input type="text" id="sessionName" placeholder="Auto-generated if empty"
                            class="w-full bg-gray-900 border border-gray-700 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500">
                    </div>
                    <button id="recordBtn" onclick="toggleRecording()"
                        class="w-full bg-red-600 hover:bg-red-700 text-white font-medium py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors">
                        <span class="w-3 h-3 rounded-full bg-white"></span>
                        <span>Start Recording</span>
                    </button>
                </div>

                <!-- Sessions List -->
                <div class="flex-1 overflow-y-auto">
                    <div class="px-4 py-3 text-xs text-gray-500 font-medium border-b border-gray-800">
                        PAST SESSIONS
                    </div>
                    <div id="sessionsList" class="divide-y divide-gray-800">
                        <!-- Sessions will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Center - Recording Info / Video Placeholder -->
            <div class="flex-1 flex flex-col bg-gradient-to-b from-gray-900 to-black">
                <div class="flex-1 flex items-center justify-center p-8">
                    <div id="centerContent" class="text-center">
                        <!-- Idle State -->
                        <div id="idleState">
                            <div class="text-6xl mb-4">üéØ</div>
                            <h2 class="text-2xl font-semibold mb-2">Ready to Record</h2>
                            <p class="text-gray-500 max-w-md">Select an activity type and click "Start Recording" to begin capturing sensor data.</p>
                        </div>

                        <!-- Recording State -->
                        <div id="recordingState" class="hidden">
                            <div class="recording-pulse text-6xl mb-4">üî¥</div>
                            <h2 class="text-2xl font-semibold mb-2">Recording...</h2>
                            <div id="detectedActivityContainer" class="mb-4">
                                <div class="text-sm text-gray-500 mb-1">Detected Activity:</div>
                                <!-- SVG Icon Container -->
                                <div id="activityIconContainer" class="flex justify-center mb-2">
                                    <div id="activityIcon" style="display: none;"></div>
                                </div>
                                <div id="detectedActivity" class="text-xl">
                                    <span id="activityLabel" class="text-green-400 font-semibold">Waiting...</span>
                                    <span id="activityConfidence" class="text-lg text-gray-400 ml-2"></span>
                                </div>
                                <div class="text-sm text-gray-500 mt-1">Selected Activity: <span id="selectedActivity" class="text-blue-400">Walking</span></div>
                            </div>
                            <div class="flex items-center justify-center gap-8 text-sm text-gray-400">
                                <div>
                                    <span class="text-2xl font-mono text-white" id="recordingDuration">00:00</span>
                                    <div class="text-xs">Duration</div>
                                </div>
                                <div>
                                    <span class="text-2xl font-mono text-green-400" id="footCount">0</span>
                                    <div class="text-xs">Foot Readings</div>
                                </div>
                                <div>
                                    <span class="text-2xl font-mono text-orange-400" id="accelCount">0</span>
                                    <div class="text-xs">Accel Readings</div>
                                </div>
                            </div>
                        </div>

                        <!-- Replay State -->
                        <div id="replayState" class="hidden">
                            <div class="text-6xl mb-4">‚ñ∂Ô∏è</div>
                            <h2 class="text-2xl font-semibold mb-2">Replay Mode</h2>
                            <div id="replaySession" class="text-xl text-blue-400 mb-4"></div>
                            <div id="detectedActivityContainer" class="mb-4">
                                <div class="text-sm text-gray-500 mb-1">Detected Activity:</div>
                                <!-- SVG Icon Container -->
                                <div id="activityIconContainer" class="flex justify-center mb-2">
                                    <div id="activityIcon" style="display: none;"></div>
                                </div>
                                <div id="detectedActivity" class="text-xl">
                                    <span id="activityLabel" class="text-green-400 font-semibold">Waiting...</span>
                                    <span id="activityConfidence" class="text-lg text-gray-400 ml-2"></span>
                                </div>
                                <div class="text-sm text-gray-500 mt-1">Session Activity: <span id="selectedActivity" class="text-blue-400">-</span></div>
                            </div>
                            <div id="replayTime" class="text-lg text-gray-400 mb-3 font-mono">
                                <span id="replayCurrentTime">00:00</span>
                                <span class="text-gray-600"> / </span>
                                <span id="replayTotalTime">00:00</span>
                            </div>
                            <div class="flex items-center justify-center gap-4">
                                <button onclick="replayControl('prev')" class="p-2 bg-gray-800 rounded hover:bg-gray-700">‚èÆ</button>
                                <button onclick="replayControl('play')" id="playPauseBtn" class="p-3 bg-blue-600 rounded hover:bg-blue-700">‚ñ∂</button>
                                <button onclick="replayControl('next')" class="p-2 bg-gray-800 rounded hover:bg-gray-700">‚è≠</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar - Live Sensor Data -->
            <div class="w-80 bg-black border-l border-gray-800 overflow-y-auto">
                <div class="p-6 space-y-6">
                    <!-- Foot Pressure -->
                    <div>
                        <h3 class="text-sm font-semibold mb-4 tracking-wide flex items-center justify-between">
                            FOOT PRESSURE
                            <span id="footStatus" class="text-xs text-gray-500 font-normal">Waiting...</span>
                        </h3>
                        <div class="grid grid-cols-2 gap-4">
                            <!-- Left Foot -->
                            <div class="bg-gray-900 rounded-lg p-3">
                                <div class="text-xs text-gray-500 mb-2">LEFT</div>
                                <div id="leftFootBars" class="flex items-end justify-around h-24 gap-0.5">
                                    <!-- 18 bars for left foot sensors -->
                                </div>
                                <div class="mt-2 text-xs text-gray-400 flex justify-between">
                                    <span>Max: <span id="leftMax">0</span></span>
                                    <span>Avg: <span id="leftAvg">0</span></span>
                                </div>
                            </div>
                            <!-- Right Foot -->
                            <div class="bg-gray-900 rounded-lg p-3">
                                <div class="text-xs text-gray-500 mb-2">RIGHT</div>
                                <div id="rightFootBars" class="flex items-end justify-around h-24 gap-0.5">
                                    <!-- 18 bars for right foot sensors -->
                                </div>
                                <div class="mt-2 text-xs text-gray-400 flex justify-between">
                                    <span>Max: <span id="rightMax">0</span></span>
                                    <span>Avg: <span id="rightAvg">0</span></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Accelerometer -->
                    <div>
                        <h3 class="text-sm font-semibold mb-4 tracking-wide flex items-center justify-between">
                            ACCELEROMETER
                            <span id="accelStatus" class="text-xs text-gray-500 font-normal">Waiting...</span>
                        </h3>

                        <!-- Acceleration -->
                        <div class="mb-4">
                            <div class="text-xs text-gray-500 mb-2">Acceleration (m/s¬≤)</div>
                            <div class="grid grid-cols-3 gap-2">
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-blue-400">X</div>
                                    <div id="accX" class="text-lg font-mono">0.00</div>
                                </div>
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-green-400">Y</div>
                                    <div id="accY" class="text-lg font-mono">0.00</div>
                                </div>
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-orange-400">Z</div>
                                    <div id="accZ" class="text-lg font-mono">0.00</div>
                                </div>
                            </div>
                        </div>

                        <!-- Gyroscope -->
                        <div class="mb-4">
                            <div class="text-xs text-gray-500 mb-2">Gyroscope (¬∞/s)</div>
                            <div class="grid grid-cols-3 gap-2">
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-blue-400">X</div>
                                    <div id="gyroX" class="text-lg font-mono">0.00</div>
                                </div>
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-green-400">Y</div>
                                    <div id="gyroY" class="text-lg font-mono">0.00</div>
                                </div>
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-orange-400">Z</div>
                                    <div id="gyroZ" class="text-lg font-mono">0.00</div>
                                </div>
                            </div>
                        </div>

                        <!-- Angle -->
                        <div>
                            <div class="text-xs text-gray-500 mb-2">Angle (¬∞)</div>
                            <div class="grid grid-cols-3 gap-2">
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-purple-400">Roll</div>
                                    <div id="roll" class="text-lg font-mono">0.00</div>
                                </div>
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-pink-400">Pitch</div>
                                    <div id="pitch" class="text-lg font-mono">0.00</div>
                                </div>
                                <div class="bg-gray-900 rounded p-2 text-center">
                                    <div class="text-xs text-cyan-400">Yaw</div>
                                    <div id="yaw" class="text-lg font-mono">0.00</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Section -->
        <div class="bg-[#0b0b0b] border-t border-gray-800 text-gray-300 w-full">
            <!-- Timeline Header -->
            <div class="bg-gray-900 px-4 py-2 flex items-center gap-3 border-b border-gray-700">
                <span class="text-sm font-medium">Timeline</span>
                <div class="flex-1"></div>
                <div id="timelineRange" class="text-gray-400 text-sm font-mono">00:00 ‚Äî 00:00</div>
                <div class="flex-1"></div>
                <button onclick="zoomTimeline(-1)" class="p-1.5 hover:bg-gray-700 rounded text-gray-300">‚àí</button>
                <button onclick="zoomTimeline(1)" class="p-1.5 hover:bg-gray-700 rounded text-gray-300">+</button>
            </div>

            <!-- Timeline Container -->
            <div class="flex w-full">
                <!-- Track Labels -->
                <div class="w-32 bg-gray-850 border-r border-gray-700">
                    <div class="h-8 border-b border-gray-700 flex items-center px-3">
                        <span class="text-[10px] text-gray-400">Time</span>
                    </div>
                    <div class="h-12 border-b border-gray-700 flex items-center px-3 bg-gray-800">
                        <span class="text-xs text-gray-300">Activity</span>
                    </div>
                </div>

                <!-- Timeline Area -->
                <div class="flex-1 overflow-x-auto relative" id="timelineScroll">
                    <!-- Ruler -->
                    <div id="timelineRuler" class="h-8 bg-gray-900 border-b border-gray-700 relative">
                        <!-- Time markers will be generated dynamically -->
                    </div>

                    <!-- Activity Track -->
                    <div id="activityTrack" class="h-12 bg-gray-800 border-b border-gray-700 relative">
                        <!-- Activity segments will appear here -->
                    </div>

                    <!-- Playhead -->
                    <div id="playhead" class="absolute top-0 w-0.5 bg-red-500 z-10 hidden pointer-events-none" style="left: 0; height: 100%;">
                        <div class="absolute -top-1 -left-1.5 w-3 h-2 bg-red-500"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const SERVER_URL = 'http://localhost:4100';

        // State
        let isRecording = false;
        let currentSessionId = null;
        let recordingStartTime = null;
        let recordingTimer = null;
        let footReadingCount = 0;
        let accelReadingCount = 0;
        let sessions = [];
        // Replay state
        let replayWindows = [];           // Currently loaded windows with raw data
        let replayWindowsMetadata = [];   // All windows metadata (lightweight)
        let replayCurrentWindowIndex = 0; // Current window index
        let replayReadingIndex = 0;       // Current reading within window
        let replaySpeed = 1.0;            // Playback speed multiplier (1x default)
        let replayPreloadOffset = 10;     // Preload when within 10 windows of end
        let replayBatchSize = 20;         // Windows per batch
        let isReplaying = false;          // Playback active flag
        let replayTimer = null;           // Interval timer for playback
        let replaySessionId = null;       // Current replay session ID
        let replayTotalWindows = 0;       // Total windows in session
        let replaySessionDuration = 0;    // Total session duration in seconds (from timestamps)
        let replayStartTime = null;       // Timestamp when replay started (for elapsed time tracking)
        let replaySessionStartTime = null; // Session created_at timestamp in ms (for window offset calculation)
        let replayPausedElapsedTime = 0;  // Milliseconds elapsed before pause (for resume continuity)

        // Activity detection
        let activityDetector = null;      // Activity detector instance

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initFootBars();
            loadSessions();

            // Initialize activity detector
            activityDetector = new ActivityDetector();
            connectSocket();
            checkActiveSession();
        });

        // Check if there's an active session on the server and sync UI state
        async function checkActiveSession() {
            // Don't run if already recording
            if (isRecording) return;

            try {
                const response = await fetch(`${SERVER_URL}/api/sessions/active`);
                const session = await response.json();

                if (session && session.status === 'recording') {
                    // Restore recording state from server
                    currentSessionId = session.id;
                    isRecording = true;
                    recordingStartTime = new Date(session.created_at).getTime();
                    updateRecordingUI(true, session.activity_type);
                    startRecordingTimer();
                    console.log('[Session] Restored active session:', session.id);
                }
            } catch (error) {
                console.error('Failed to check active session:', error);
            }
        }

        // Initialize foot pressure bars
        function initFootBars() {
            const leftBars = document.getElementById('leftFootBars');
            const rightBars = document.getElementById('rightFootBars');

            for (let i = 0; i < 18; i++) {
                leftBars.innerHTML += `<div class="w-1 bg-blue-500 sensor-bar" style="height: 5%"></div>`;
                rightBars.innerHTML += `<div class="w-1 bg-green-500 sensor-bar" style="height: 5%"></div>`;
            }
        }

        // Load sessions from API
        async function loadSessions() {
            try {
                const response = await fetch(`${SERVER_URL}/api/sessions`);
                sessions = await response.json();
                renderSessions();
            } catch (error) {
                console.error('Failed to load sessions:', error);
            }
        }

        // Render sessions list
        function renderSessions() {
            const list = document.getElementById('sessionsList');

            if (sessions.length === 0) {
                list.innerHTML = '<div class="p-4 text-gray-500 text-sm">No sessions yet</div>';
                return;
            }

            list.innerHTML = sessions.map(s => `
                <div class="session-item px-4 py-3 hover:bg-gray-900 transition-colors">
                    <div class="flex items-center justify-between mb-1">
                        <span class="font-medium text-sm cursor-pointer flex-1 truncate mr-2" onclick="selectSession('${s.id}')">${s.name || 'Unnamed'}</span>
                        <div class="flex items-center gap-1 flex-shrink-0">
                            <button onclick="event.stopPropagation(); renameSession('${s.id}', '${s.name.replace(/'/g, "\\'")}');"
                                    class="text-xs px-1.5 py-1 bg-gray-700 hover:bg-gray-600 rounded text-gray-300 flex-shrink-0 whitespace-nowrap"
                                    title="Rename session">
                                ‚úèÔ∏è
                            </button>
                            <button onclick="event.stopPropagation(); deleteSession('${s.id}', '${s.name.replace(/'/g, "\\'")}');"
                                    class="text-xs px-1.5 py-1 bg-red-900 hover:bg-red-800 rounded text-red-300 flex-shrink-0 whitespace-nowrap"
                                    title="Delete session">
                                üóëÔ∏è
                            </button>
                            <span class="text-xs px-2 py-1 rounded flex-shrink-0 ${s.status === 'recording' ? 'bg-red-900 text-red-300' : 'bg-gray-700 text-gray-400'}">
                                ${s.status}
                            </span>
                        </div>
                    </div>
                    <div class="flex items-center gap-2 text-xs text-gray-500 cursor-pointer" onclick="selectSession('${s.id}')">
                        ${s.activity_type ? `<span class="bg-blue-900 text-blue-300 px-1.5 py-0.5 rounded">${s.activity_type}</span>` : ''}
                        <span>${new Date(s.created_at).toLocaleTimeString()}</span>
                    </div>
                </div>
            `).join('');
        }

        // Throttle function to prevent rapid calls
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // Throttled version of loadSessions
        const throttledLoadSessions = throttle(loadSessions, 2000);

        // Connect to Socket.IO
        function connectSocket() {
            // Connect to /iot namespace only
            const iotSocket = io(`${SERVER_URL}/iot`, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });

            iotSocket.on('connect', () => {
                updateConnectionStatus(true);
                console.log('[Socket.IO] Connected to /iot namespace');
            });

            iotSocket.on('disconnect', (reason) => {
                updateConnectionStatus(false);
                console.log('[Socket.IO] Disconnected:', reason);
            });

            iotSocket.on('connect_error', (error) => {
                console.error('[Socket.IO] Connection error:', error);
                updateConnectionStatus(false);
            });

            // Listen for session events (throttled to prevent rapid updates)
            iotSocket.on('session_started', (data) => {
                console.log('[Socket.IO] Session started:', data);
                throttledLoadSessions();
            });

            iotSocket.on('session_stopped', (data) => {
                console.log('[Socket.IO] Session stopped:', data);
                throttledLoadSessions();
            });

            // Listen for live sensor data (no logging - too frequent at 30Hz)
            iotSocket.on('foot_data', (data) => {
                updateFootDisplay(data);

                // Update activity detector with new foot data (ONLY during recording)
                if (activityDetector && isRecording) {
                    activityDetector.updateFootData(data.data);

                    // Trigger detection (if we also have accel data)
                    const result = activityDetector.detectActivity();
                    if (result.confidence > 0) {
                        updateActivityDisplay(result.activity, result.confidence);
                    }
                }
            });

            iotSocket.on('accel_data', (data) => {
                updateAccelDisplay(data);

                // Update activity detector and run detection (ONLY during recording)
                if (activityDetector && isRecording) {
                    activityDetector.updateAccelData(data.data);

                    // Trigger detection on every accel reading
                    const result = activityDetector.detectActivity();
                    updateActivityDisplay(result.activity, result.confidence);

                    // Send detected activity to backend for window labeling
                    if (currentSessionId && result.confidence > 0) {
                        window.iotSocket.emit('activity_detected', {
                            session_id: currentSessionId,
                            activity: result.activity,
                            confidence: result.confidence,
                            timestamp: new Date().toISOString()
                        });
                    }
                }
            });

            // Store socket for later use
            window.iotSocket = iotSocket;
        }

        // Activity to SVG content mapping (embedded to avoid CORS issues)
        const activitySvgMap = {
            'Sitting': `<svg width="220" height="200" viewBox="0 0 220 200" xmlns="http://www.w3.org/2000/svg">
                <!-- Head -->
                <circle cx="80" cy="30" r="16" fill="white" />
                <!-- Torso -->
                <rect x="70" y="46" width="30" height="65" rx="14" fill="white" />
                <!-- Arm resting -->
                <rect x="82" y="65" width="12" height="45" rx="6" fill="white" />
                <!-- Thigh (folded under body) -->
                <rect x="95" y="105" width="55" height="18" rx="9" fill="white" />
                <!-- Lower leg (bent backward) -->
                <rect x="130" y="115" width="18" height="50" rx="9" fill="white" />
                <!-- Foot -->
                <rect x="120" y="160" width="35" height="12" rx="6" fill="white" />
            </svg>`,
            'Standing': `<svg width="120" height="240" viewBox="0 0 120 240" xmlns="http://www.w3.org/2000/svg">
                <!-- Head -->
                <circle cx="60" cy="30" r="20" fill="white" />
                <!-- Body -->
                <rect x="40" y="55" width="40" height="90" rx="20" fill="white" />
                <!-- Left Arm -->
                <rect x="20" y="60" width="20" height="80" rx="10" fill="white" />
                <!-- Right Arm -->
                <rect x="80" y="60" width="20" height="80" rx="10" fill="white" />
                <!-- Left Leg -->
                <rect x="42" y="140" width="16" height="90" rx="8" fill="white" />
                <!-- Right Leg -->
                <rect x="62" y="140" width="16" height="90" rx="8" fill="white" />
            </svg>`
        };

        // Activity to color mapping for timeline segments
        const activityColors = {
            'Sitting': '#22c55e',      // green-500
            'Standing': '#3b82f6',     // blue-500
            'Lying_Down': '#f59e0b',   // amber-500
            'Bent_Forward': '#8b5cf6', // violet-500
            'Jumping': '#ef4444'       // red-500
        };

        // Update the detected activity display
        function updateActivityDisplay(activity, confidence) {
            if (!isRecording && !isReplaying) return;

            // Debug logging during replay (throttled to avoid spam)
            if (isReplaying) {
                if (!window.lastActivityLog || window.lastActivityLog !== activity) {
                    // Get current replay time for context
                    const elapsedMs = replayStartTime ? Date.now() - replayStartTime : 0;
                    const elapsedSec = Math.floor(elapsedMs / 1000);
                    console.log('[Activity Detection] At', elapsedSec + 's:', activity, '(' + confidence + '%)');
                    window.lastActivityLog = activity;
                }
            }

            // Determine which state is active and get elements from correct container
            let activityLabelEl, confidenceEl, activityIconEl;

            if (isReplaying) {
                // Get elements from replay state (visible during replay)
                const replayState = document.getElementById('replayState');
                activityLabelEl = replayState?.querySelector('#activityLabel');
                confidenceEl = replayState?.querySelector('#activityConfidence');
                activityIconEl = replayState?.querySelector('#activityIcon');
            } else {
                // Get elements from recording state (visible during recording)
                const recordingState = document.getElementById('recordingState');
                activityLabelEl = recordingState?.querySelector('#activityLabel');
                confidenceEl = recordingState?.querySelector('#activityConfidence');
                activityIconEl = recordingState?.querySelector('#activityIcon');
            }

            if (activityLabelEl && confidenceEl) {
                activityLabelEl.textContent = activity;
                confidenceEl.textContent = `(${confidence}%)`;

                // Color coding based on confidence
                if (confidence >= 80) {
                    activityLabelEl.className = 'text-green-400 font-semibold';
                } else if (confidence >= 60) {
                    activityLabelEl.className = 'text-yellow-400 font-semibold';
                } else {
                    activityLabelEl.className = 'text-orange-400 font-semibold';
                }
            }

            // Display SVG icon if available for this activity
            if (activityIconEl) {
                const svgContent = activitySvgMap[activity];
                if (svgContent) {
                    // Display the embedded SVG
                    activityIconEl.innerHTML = svgContent;
                    activityIconEl.style.display = 'block';
                    // Scale down the SVG
                    const svgElement = activityIconEl.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.width = '80px';
                        svgElement.style.height = 'auto';
                    }
                } else {
                    // No SVG for this activity, hide the icon
                    activityIconEl.style.display = 'none';
                    activityIconEl.innerHTML = '';
                }
            }
        }

        // Update connection status indicator
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.innerHTML = `
                    <span class="w-2 h-2 rounded-full bg-green-500"></span>
                    <span class="text-green-500">Connected</span>
                `;
            } else {
                status.innerHTML = `
                    <span class="w-2 h-2 rounded-full bg-gray-500"></span>
                    <span class="text-gray-500">Disconnected</span>
                `;
            }
        }

        // Toggle recording
        async function toggleRecording() {
            if (isRecording) {
                await stopRecording();
            } else {
                await startRecording();
            }
        }

        // Start recording
        async function startRecording() {
            const sessionName = document.getElementById('sessionName').value;

            try {
                const response = await fetch(`${SERVER_URL}/api/sessions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: sessionName || undefined
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to create session');
                }

                const session = await response.json();
                currentSessionId = session.id;
                isRecording = true;
                recordingStartTime = Date.now();
                footReadingCount = 0;
                accelReadingCount = 0;

                // Reset activity detector
                if (activityDetector) {
                    activityDetector.reset();
                }
                document.getElementById('activityLabel').textContent = 'Waiting...';
                document.getElementById('activityConfidence').textContent = '';

                // Update UI
                updateRecordingUI(true);
                startRecordingTimer();
                // Don't call loadSessions() here - socket event will handle it

                console.log('Recording started:', session);
            } catch (error) {
                console.error('Failed to start recording:', error);
                alert('Failed to start recording: ' + error.message);
            }
        }

        // Stop recording
        async function stopRecording() {
            if (!currentSessionId) return;

            try {
                const response = await fetch(`${SERVER_URL}/api/sessions/${currentSessionId}/stop`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to stop session');
                }

                isRecording = false;
                stopRecordingTimer();

                // Clear detection state
                if (activityDetector) {
                    activityDetector.reset();
                }

                updateRecordingUI(false);
                // Don't call loadSessions() here - socket event will handle it

                console.log('Recording stopped');
                currentSessionId = null;
            } catch (error) {
                console.error('Failed to stop recording:', error);
                alert('Failed to stop recording: ' + error.message);
            }
        }

        // Update recording UI
        function updateRecordingUI(recording, activityType = '') {
            const btn = document.getElementById('recordBtn');
            const idleState = document.getElementById('idleState');
            const recordingState = document.getElementById('recordingState');
            const replayState = document.getElementById('replayState');

            if (recording) {
                btn.innerHTML = `
                    <span class="w-3 h-3 rounded bg-white"></span>
                    <span>Stop Recording</span>
                `;
                btn.className = btn.className.replace('bg-red-600 hover:bg-red-700', 'bg-gray-600 hover:bg-gray-700');

                idleState.classList.add('hidden');
                replayState.classList.add('hidden');
                recordingState.classList.remove('hidden');
                document.getElementById('selectedActivity').textContent = activityType;
            } else {
                btn.innerHTML = `
                    <span class="w-3 h-3 rounded-full bg-white"></span>
                    <span>Start Recording</span>
                `;
                btn.className = btn.className.replace('bg-gray-600 hover:bg-gray-700', 'bg-red-600 hover:bg-red-700');

                idleState.classList.remove('hidden');
                recordingState.classList.add('hidden');
                replayState.classList.add('hidden');
            }
        }

        // Recording timer
        function startRecordingTimer() {
            // Prevent multiple timers
            if (recordingTimer) {
                clearInterval(recordingTimer);
            }
            recordingTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('recordingDuration').textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
        }

        // Update sensor displays (called when receiving data)
        function updateFootDisplay(data) {
            if (!data || !data.data) return;

            const foot = data.data.foot || 'LEFT';
            const values = data.data.values || [];
            const max = data.data.max || 0;
            const avg = data.data.avg || 0;

            const barsContainer = document.getElementById(foot === 'LEFT' ? 'leftFootBars' : 'rightFootBars');
            const bars = barsContainer.querySelectorAll('.sensor-bar');

            values.forEach((val, i) => {
                if (bars[i]) {
                    const height = Math.min(100, Math.max(5, (val / 100) * 100));
                    bars[i].style.height = `${height}%`;
                }
            });

            document.getElementById(foot === 'LEFT' ? 'leftMax' : 'rightMax').textContent = max.toFixed(1);
            document.getElementById(foot === 'LEFT' ? 'leftAvg' : 'rightAvg').textContent = avg.toFixed(1);

            document.getElementById('footStatus').textContent = new Date().toLocaleTimeString();

            // Always increment counts when we're in recording state
            // This tracks data received while UI is recording
            if (isRecording) {
                footReadingCount++;
                document.getElementById('footCount').textContent = footReadingCount;
            }
        }

        function updateAccelDisplay(data) {
            if (!data || !data.data) return;

            const acc = data.data.acc || {};
            const gyro = data.data.gyro || {};
            const angle = data.data.angle || {};

            document.getElementById('accX').textContent = (acc.x || 0).toFixed(2);
            document.getElementById('accY').textContent = (acc.y || 0).toFixed(2);
            document.getElementById('accZ').textContent = (acc.z || 0).toFixed(2);

            document.getElementById('gyroX').textContent = (gyro.x || 0).toFixed(2);
            document.getElementById('gyroY').textContent = (gyro.y || 0).toFixed(2);
            document.getElementById('gyroZ').textContent = (gyro.z || 0).toFixed(2);

            document.getElementById('roll').textContent = (angle.roll || 0).toFixed(2);
            document.getElementById('pitch').textContent = (angle.pitch || 0).toFixed(2);
            document.getElementById('yaw').textContent = (angle.yaw || 0).toFixed(2);

            document.getElementById('accelStatus').textContent = new Date().toLocaleTimeString();

            // Always increment counts when we're in recording state
            if (isRecording) {
                accelReadingCount++;
                document.getElementById('accelCount').textContent = accelReadingCount;
            }
        }

        // Select session for replay
        async function selectSession(sessionId) {
            if (isRecording) {
                alert('Stop recording before selecting a session');
                return;
            }

            // Stop any active replay before switching sessions
            if (isReplaying) {
                pauseReplay();
            }

            try {
                // Load first batch of windows with raw data for replay
                const replayResponse = await fetch(`${SERVER_URL}/api/sessions/${sessionId}/replay?offset=0&limit=${replayBatchSize}`);
                const replayData = await replayResponse.json();

                // Load ALL windows metadata (without raw_data) for timeline rendering
                // This is a lightweight call that gets labels for all windows
                const metadataResponse = await fetch(`${SERVER_URL}/api/sessions/${sessionId}/windows`);
                const allWindowsMetadata = await metadataResponse.json();

                // Initialize replay state
                replaySessionId = sessionId;
                replayWindows = replayData.windows || [];
                replayTotalWindows = replayData.total_windows || 0;
                replayCurrentWindowIndex = 0;
                replayReadingIndex = 0;
                replayStartTime = null;  // Reset replay timer
                replayPausedElapsedTime = 0;  // Reset paused time for new session

                // Reset activity detector and display for new session
                if (activityDetector) {
                    activityDetector.reset();
                }

                // Reset activity display to "Waiting..." for replay
                const replayState = document.getElementById('replayState');
                if (replayState) {
                    const activityLabelEl = replayState.querySelector('#activityLabel');
                    const confidenceEl = replayState.querySelector('#activityConfidence');
                    if (activityLabelEl && confidenceEl) {
                        activityLabelEl.textContent = 'Waiting...';
                        activityLabelEl.className = 'text-gray-400';
                        confidenceEl.textContent = '';
                    }
                }

                // Calculate actual recording duration
                let totalSeconds = 0;

                // Try using session timestamps first (recording start to stop)
                if (replayData.session.created_at && replayData.session.stopped_at) {
                    const startTime = new Date(replayData.session.created_at);
                    const stopTime = new Date(replayData.session.stopped_at);
                    const sessionDuration = Math.floor((stopTime - startTime) / 1000);

                    console.log('[Duration Calculation] Session timestamps:', {
                        created_at: replayData.session.created_at,
                        stopped_at: replayData.session.stopped_at,
                        startTime: startTime.toISOString(),
                        stopTime: stopTime.toISOString(),
                        calculatedDuration: sessionDuration + 's'
                    });

                    // Sanity check: if session was left open for more than 2 hours, use window span instead
                    const MAX_REASONABLE_DURATION = 2 * 60 * 60; // 2 hours in seconds

                    if (sessionDuration <= MAX_REASONABLE_DURATION) {
                        // Session duration is reasonable, use it
                        totalSeconds = sessionDuration;
                        console.log('[Duration Calculation] Using session timestamp duration:', totalSeconds + 's');
                    } else {
                        // Session was left open too long, fall back to window span
                        console.warn('[Replay] Session duration exceeds 2 hours, using window span instead');
                        if (allWindowsMetadata.length > 0) {
                            const firstWindow = allWindowsMetadata[0];
                            const lastWindow = allWindowsMetadata[allWindowsMetadata.length - 1];
                            if (firstWindow.start_time && lastWindow.end_time) {
                                const duration_ms = lastWindow.end_time - firstWindow.start_time;
                                totalSeconds = Math.ceil(duration_ms / 1000);
                                console.log('[Duration Calculation] Using window span duration:', totalSeconds + 's');
                            }
                        }
                    }
                } else if (allWindowsMetadata.length > 0) {
                    // No session timestamps, use window span
                    const firstWindow = allWindowsMetadata[0];
                    const lastWindow = allWindowsMetadata[allWindowsMetadata.length - 1];
                    if (firstWindow.start_time && lastWindow.end_time) {
                        const duration_ms = lastWindow.end_time - firstWindow.start_time;
                        totalSeconds = Math.ceil(duration_ms / 1000);
                        console.log('[Duration Calculation] Using window span (no session timestamps):', totalSeconds + 's');
                    } else {
                        // Fallback to window count
                        totalSeconds = Math.floor(replayTotalWindows * 0.5);
                        console.log('[Duration Calculation] Fallback to window count estimate:', totalSeconds + 's');
                    }
                } else {
                    // Fallback to window count if no windows loaded yet
                    totalSeconds = Math.floor(replayTotalWindows * 0.5);
                    console.log('[Duration Calculation] Fallback to window count estimate (no windows):', totalSeconds + 's');
                }

                // Store for use in playback
                replaySessionDuration = totalSeconds;

                // Store session start time for timestamp-based playback
                if (replayData.session.created_at) {
                    replaySessionStartTime = new Date(replayData.session.created_at).getTime();
                    console.log('[Duration Calculation] Session start time:', replaySessionStartTime, '(' + new Date(replaySessionStartTime).toISOString() + ')');
                }

                console.log('[Session Load] FINAL VALUES:');
                console.log('  - replaySessionDuration:', replaySessionDuration, 'seconds');
                console.log('  - replaySessionStartTime:', replaySessionStartTime, '(' + new Date(replaySessionStartTime).toISOString() + ')');
                console.log('  - Total windows:', replayTotalWindows);
                console.log('  - Metadata windows:', allWindowsMetadata.length);

                const totalMinutes = Math.floor(totalSeconds / 60);
                const totalSecs = totalSeconds % 60;
                document.getElementById('replayTotalTime').textContent =
                    `${String(totalMinutes).padStart(2, '0')}:${String(totalSecs).padStart(2, '0')}`;
                document.getElementById('replayCurrentTime').textContent = '00:00';

                // Update UI - remove active class from all sessions
                document.querySelectorAll('.session-item').forEach(el => el.classList.remove('active'));

                // Show replay state
                document.getElementById('idleState').classList.add('hidden');
                document.getElementById('recordingState').classList.add('hidden');
                document.getElementById('replayState').classList.remove('hidden');
                document.getElementById('replaySession').textContent = replayData.session.activity_type ?
                    `${replayData.session.name} - ${replayData.session.activity_type}` :
                    replayData.session.name;
                document.getElementById('selectedActivity').textContent = replayData.session.activity_type || '-';

                // Update timeline with session data and ALL windows metadata (not just first batch)
                updateTimeline({
                    ...replayData.session,
                    windows: allWindowsMetadata
                });

                console.log(`Loaded session: ${replayWindows.length} windows for replay (${replayTotalWindows} total), ${allWindowsMetadata.length} windows for timeline`);
            } catch (error) {
                console.error('Failed to load session:', error);
                alert('Failed to load session for replay');
            }
        }

        // Load next batch of windows for replay
        async function loadWindowsBatch(offset) {
            if (!replaySessionId) return;

            try {
                const response = await fetch(`${SERVER_URL}/api/sessions/${replaySessionId}/replay?offset=${offset}&limit=${replayBatchSize}`);
                const data = await response.json();

                // Append new windows to replay buffer
                replayWindows.push(...data.windows);

                console.log(`Loaded batch: offset=${offset}, count=${data.windows.length}, total in buffer=${replayWindows.length}`);

                return data.has_more;
            } catch (error) {
                console.error('Failed to load window batch:', error);
                return false;
            }
        }

        // Rename session
        async function renameSession(sessionId, currentName) {
            const newName = prompt('Enter new name for session:', currentName);
            if (!newName || newName === currentName) return;

            try {
                const response = await fetch(`${SERVER_URL}/api/sessions/${sessionId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName })
                });

                if (!response.ok) {
                    throw new Error('Failed to rename session');
                }

                // Refresh session list
                await loadSessions();

                // Update replay state if this is the current session
                if (replaySessionId === sessionId) {
                    document.getElementById('replaySession').textContent = newName;
                }

                console.log('Session renamed successfully');
            } catch (error) {
                console.error('Failed to rename session:', error);
                alert('Failed to rename session');
            }
        }

        // Delete session
        async function deleteSession(sessionId, sessionName) {
            if (!confirm(`Are you sure you want to delete "${sessionName}"?\n\nThis will permanently delete all recorded data.`)) {
                return;
            }

            try {
                const response = await fetch(`${SERVER_URL}/api/sessions/${sessionId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to delete session');
                }

                const result = await response.json();
                console.log(`Session deleted: ${result.windows_deleted} windows removed`);

                // Stop replay if this session is being replayed
                if (replaySessionId === sessionId) {
                    pauseReplay();
                    replaySessionId = null;
                    replayWindows = [];
                    document.getElementById('replayState').classList.add('hidden');
                    document.getElementById('idleState').classList.remove('hidden');
                }

                // Refresh session list
                await loadSessions();

                alert(`Session deleted successfully (${result.windows_deleted} windows removed)`);
            } catch (error) {
                console.error('Failed to delete session:', error);
                alert('Failed to delete session');
            }
        }

        /**
         * Group consecutive windows with same label into activity segments
         *
         * CRITICAL FIXES (2025-12-20):
         * 1. Timeline segments now use replaySessionStartTime as reference point (not session.created_at)
         * 2. Timeline duration now uses replaySessionDuration (not recalculated from timestamps)
         * 3. This ensures timeline segments align perfectly with playhead position
         *
         * @param {Array} windows - Array of window objects with label, start_time, end_time
         * @returns {Array} Array of segments: [{label, start_time, end_time}, ...]
         */
        function groupActivitySegments(windows) {
            if (!windows || windows.length === 0) return [];

            console.log('[Segment Grouping] Processing', windows.length, 'windows');

            // Count labels for debugging
            const labelCounts = {};
            windows.forEach(w => {
                const label = w.label || 'unlabeled';
                labelCounts[label] = (labelCounts[label] || 0) + 1;
            });
            console.log('[Segment Grouping] Label distribution:', labelCounts);

            const segments = [];
            let currentSegment = null;

            windows.forEach((window, idx) => {
                const label = window.label;

                // Debug: Log first few and last few windows to see their labels
                if (idx < 5 || idx >= windows.length - 5) {
                    console.log(`[Segment] Window ${idx}/${windows.length}:`, {
                        label: label,
                        start_time: window.start_time,
                        end_time: window.end_time,
                        window_id: window.window_id
                    });
                }

                // Skip unlabeled windows (gaps)
                if (!label) {
                    // If we were building a segment, finish it
                    if (currentSegment) {
                        segments.push(currentSegment);
                        currentSegment = null;
                    }
                    return;
                }

                // Start new segment or extend current one
                if (!currentSegment || currentSegment.label !== label) {
                    // Finish previous segment
                    if (currentSegment) {
                        segments.push(currentSegment);
                    }
                    // Start new segment
                    currentSegment = {
                        label: label,
                        start_time: window.start_time,
                        end_time: window.end_time
                    };
                } else {
                    // Extend current segment
                    currentSegment.end_time = window.end_time;
                }
            });

            // Don't forget the last segment
            if (currentSegment) {
                segments.push(currentSegment);
            }

            return segments;
        }

        // Update timeline with session data
        function updateTimeline(session) {
            const windows = session.windows || [];
            if (windows.length === 0) {
                document.getElementById('timelineRange').textContent = '00:00 ‚Äî 00:00';
                return;
            }

            // CRITICAL: Use the same duration value as playhead to ensure consistency
            // The playhead uses replaySessionDuration, so timeline MUST use the same value
            // Otherwise segments and playhead will be misaligned
            const duration = replaySessionDuration;

            // For reference calculations only (not for positioning)
            const startTime = new Date(session.created_at);
            const endTime = new Date(session.stopped_at || session.created_at);
            const sessionTimestampDuration = (endTime - startTime) / 1000;

            console.log('[Timeline] Using duration:', duration, 'seconds (same as playhead)');
            console.log('[Timeline] Verification - session timestamp duration:', sessionTimestampDuration, 'seconds');
            if (Math.abs(duration - sessionTimestampDuration) > 1) {
                console.warn('[Timeline] WARNING: Duration mismatch! Timeline duration:', duration, 'vs session timestamps:', sessionTimestampDuration);
            }

            // Update time range display
            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60).toString().padStart(2, '0');
                const s = Math.floor(seconds % 60).toString().padStart(2, '0');
                return `${m}:${s}`;
            };

            document.getElementById('timelineRange').textContent = `${formatTime(0)} ‚Äî ${formatTime(duration)}`;

            // Generate timeline markers
            const ruler = document.getElementById('timelineRuler');
            const activityTrack = document.getElementById('activityTrack');

            // Clear existing content
            ruler.innerHTML = '';
            if (activityTrack) {
                activityTrack.innerHTML = '';
            }

            // Generate time markers with adaptive interval (like video players)
            // Determine marker interval based on duration
            let markerInterval; // seconds between markers
            if (duration <= 30) {
                markerInterval = 5;  // Every 5 seconds for videos under 30s
            } else if (duration <= 120) {
                markerInterval = 10; // Every 10 seconds for videos under 2 minutes
            } else if (duration <= 600) {
                markerInterval = 30; // Every 30 seconds for videos under 10 minutes
            } else {
                markerInterval = 60; // Every minute for longer videos
            }

            // Calculate number of markers needed
            const markerCount = Math.ceil(duration / markerInterval) + 1;

            // Generate markers at regular intervals
            for (let i = 0; i < markerCount; i++) {
                const timeInSeconds = i * markerInterval;

                // Don't go past the actual duration
                if (timeInSeconds > duration) break;

                const marker = document.createElement('div');
                marker.className = 'absolute flex items-center justify-center border-r border-gray-600 h-full';

                // Position marker at correct percentage
                const position = (timeInSeconds / duration) * 100;
                marker.style.left = `${position}%`;

                // Width of marker cell (distance to next marker)
                const nextTime = Math.min((i + 1) * markerInterval, duration);
                const widthInSeconds = nextTime - timeInSeconds;
                const width = (widthInSeconds / duration) * 100;
                marker.style.width = `${width}%`;

                // Display formatted time
                marker.innerHTML = `<span class="text-[10px] text-gray-400">${formatTime(timeInSeconds)}</span>`;

                ruler.appendChild(marker);
            }

            // Group windows into activity segments
            const activitySegments = groupActivitySegments(windows);
            console.log('[Timeline] Total windows:', windows.length);
            console.log('[Timeline] Windows with labels:', windows.filter(w => w.label).length);
            console.log('[Timeline] Activity segments:', activitySegments.length, activitySegments);

            // Debug: Show segment details
            activitySegments.forEach((seg, idx) => {
                const segStart = (new Date(seg.start_time) - startTime) / 1000;
                const segEnd = (new Date(seg.end_time) - startTime) / 1000;
                console.log(`[Timeline] Segment ${idx}: ${seg.label} from ${segStart.toFixed(1)}s to ${segEnd.toFixed(1)}s`);
            });

            // Render activity segments on the activity track
            if (activityTrack) {
                activitySegments.forEach((segment, idx) => {
                    // CRITICAL: Calculate segment position relative to SESSION START TIME (replaySessionStartTime)
                    // This must match how playhead calculates its position
                    const segmentStart = (segment.start_time - replaySessionStartTime) / 1000;
                    const segmentEnd = (segment.end_time - replaySessionStartTime) / 1000;
                    const segmentDuration = segmentEnd - segmentStart;

                    const left = (segmentStart / duration) * 100;
                    const width = (segmentDuration / duration) * 100;

                    // Debug logging for segment positioning
                    console.log(`[Timeline Segment ${idx}] "${segment.label}":`, {
                        startTime: segmentStart.toFixed(2) + 's',
                        endTime: segmentEnd.toFixed(2) + 's',
                        duration: segmentDuration.toFixed(2) + 's',
                        position: left.toFixed(2) + '%',
                        width: width.toFixed(2) + '%',
                        totalDuration: duration + 's',
                        rawStartTime: segment.start_time,
                        rawEndTime: segment.end_time,
                        sessionStartTime: replaySessionStartTime
                    });

                    // Get color for this activity
                    const color = activityColors[segment.label] || '#6b7280'; // default gray

                    // Create segment bar
                    const segmentBar = document.createElement('div');
                    segmentBar.className = 'absolute top-0 h-full flex items-center justify-center text-xs font-medium text-white overflow-hidden';
                    segmentBar.style.left = `${left}%`;
                    segmentBar.style.width = `${width}%`;
                    segmentBar.style.backgroundColor = color;
                    segmentBar.style.opacity = '0.8';

                    // Add label text inside the bar (only if segment is wide enough)
                    const minWidthForLabel = 5; // Show label if segment > 5% of timeline
                    if (width > minWidthForLabel) {
                        segmentBar.innerHTML = `<span class="px-1 truncate">${segment.label}</span>`;
                    }

                    // Add tooltip
                    segmentBar.title = `${segment.label}: ${formatTime(segmentStart)} - ${formatTime(segmentEnd)}`;

                    activityTrack.appendChild(segmentBar);
                });
            }
        }

        // Replay controls
        function replayControl(action) {
            if (!replaySessionId) return;

            switch (action) {
                case 'play':
                    if (isReplaying) {
                        pauseReplay();
                    } else {
                        startReplay();
                    }
                    break;
                case 'prev':
                    // Jump back one window
                    if (replayCurrentWindowIndex > 0) {
                        replayCurrentWindowIndex--;
                        replayReadingIndex = 0;
                        console.log(`Previous window: ${replayCurrentWindowIndex}`);
                    }
                    break;
                case 'next':
                    // Jump forward one window
                    if (replayCurrentWindowIndex < replayTotalWindows - 1) {
                        replayCurrentWindowIndex++;
                        replayReadingIndex = 0;
                        console.log(`Next window: ${replayCurrentWindowIndex}`);

                        // Check if we need to preload
                        checkPreload();
                    }
                    break;
            }
        }

        function startReplay() {
            if (replayWindows.length === 0) {
                alert('No replay data loaded');
                return;
            }

            // If replay has finished, restart from beginning
            if (replayCurrentWindowIndex >= replayTotalWindows) {
                replayCurrentWindowIndex = 0;
                replayReadingIndex = 0;
                replayWindows = []; // Clear buffer to reload from start

                // Reload first batch
                loadWindowsBatch(0).then(() => {
                    console.log('Restarted replay from beginning');
                });

                // Reset time display
                document.getElementById('replayCurrentTime').textContent = '00:00';
            }

            isReplaying = true;
            document.getElementById('playPauseBtn').textContent = '‚è∏';

            // Show playhead during replay
            const playhead = document.getElementById('playhead');
            if (playhead) {
                playhead.classList.remove('hidden');
            }

            // Track replay start time for elapsed time calculation
            // Adjust start time to account for already-elapsed time (for pause/resume continuity)
            replayStartTime = Date.now() - replayPausedElapsedTime;

            // Reset activity detector for fresh replay detection
            if (activityDetector) {
                activityDetector.reset();
            }

            // Start playback loop
            // Calculate interval based on replay speed (default 100ms for 10Hz playback)
            const baseInterval = 100; // ms
            const interval = baseInterval / replaySpeed;

            replayTimer = setInterval(() => {
                playNextReading();
            }, interval);

            console.log('Replay started');
        }

        function pauseReplay() {
            // Save elapsed time before pausing to allow resume from same position
            if (replayStartTime) {
                replayPausedElapsedTime = Date.now() - replayStartTime;
            }

            isReplaying = false;
            document.getElementById('playPauseBtn').textContent = '‚ñ∂';

            // Hide playhead when paused
            const playhead = document.getElementById('playhead');
            if (playhead) {
                playhead.classList.add('hidden');
            }

            if (replayTimer) {
                clearInterval(replayTimer);
                replayTimer = null;
            }

            // Clear activity detector state when pausing
            if (activityDetector) {
                activityDetector.reset();
            }
        }

        // Play next sensor reading from replay buffer
        async function playNextReading() {
            if (replayWindows.length === 0) {
                pauseReplay();
                return;
            }

            // Check if we've reached the end of the session duration based on elapsed time
            if (replaySessionDuration > 0 && replayStartTime) {
                const elapsedMs = Date.now() - replayStartTime;
                const elapsedSeconds = elapsedMs / 1000;

                // Debug log every 2 seconds during playback
                if (!window.lastPlaybackLog || (elapsedSeconds - window.lastPlaybackLog) >= 2) {
                    console.log('[Playback] Elapsed:', elapsedSeconds.toFixed(2) + 's of', replaySessionDuration + 's',
                        '| Window:', replayCurrentWindowIndex, '/', replayTotalWindows,
                        '| Reading:', replayReadingIndex);
                    window.lastPlaybackLog = Math.floor(elapsedSeconds / 2) * 2; // Log every 2 seconds
                }

                if (elapsedSeconds >= replaySessionDuration) {
                    // Update playhead one final time to show the complete duration
                    updatePlayhead();
                    // Reached the end of session duration
                    pauseReplay();
                    console.log('Replay finished - reached session duration of', replaySessionDuration, 'seconds');
                    return;
                }
            }

            // Get current window (relative to loaded buffer)
            const windowIndexInBuffer = replayCurrentWindowIndex - (replayWindows.length > 0 ? 0 : 0);
            const currentWindow = replayWindows[windowIndexInBuffer];

            if (!currentWindow) {
                // No more windows with data, but keep playing to fill the time
                // Just update the playhead and continue without trying to load more data
                updatePlayhead();
                return; // Keep timer running, just don't process any data
            }

            // Check if it's time to play this window based on its timestamp
            if (currentWindow.start_time && replaySessionStartTime && replayStartTime) {
                // Calculate when this window should play (offset from session start)
                const windowOffsetMs = currentWindow.start_time - replaySessionStartTime;
                const windowOffsetSec = windowOffsetMs / 1000;

                // Calculate current elapsed replay time
                const elapsedMs = Date.now() - replayStartTime;
                const elapsedSec = elapsedMs / 1000;

                // Debug log window timing (only for first reading of each window)
                if (replayReadingIndex === 0) {
                    console.log('[Window Timing] Window', replayCurrentWindowIndex + ':', {
                        windowOffsetSec: windowOffsetSec.toFixed(2) + 's',
                        elapsedSec: elapsedSec.toFixed(2) + 's',
                        delta: (elapsedSec - windowOffsetSec).toFixed(2) + 's',
                        shouldPlay: elapsedSec >= windowOffsetSec
                    });
                }

                // If we haven't reached this window's time yet, skip it
                if (elapsedSec < windowOffsetSec) {
                    updatePlayhead();
                    return; // Try again next tick
                }
            }

            // Parse raw_data if it exists
            let rawData;
            if (typeof currentWindow.raw_data === 'string') {
                try {
                    rawData = JSON.parse(currentWindow.raw_data);
                } catch (e) {
                    console.error('Failed to parse raw_data:', e);
                    replayCurrentWindowIndex++;
                    replayReadingIndex = 0;
                    return;
                }
            } else {
                rawData = currentWindow.raw_data;
            }

            if (!rawData) {
                // No raw data, skip to next window
                replayCurrentWindowIndex++;
                replayReadingIndex = 0;
                return;
            }

            // Get sensor arrays
            const footReadings = rawData.foot || [];
            const accelReadings = rawData.accel || [];
            const maxReadings = Math.max(footReadings.length, accelReadings.length);

            // Check if we've reached end of current window
            if (replayReadingIndex >= maxReadings) {
                // Move to next window
                replayCurrentWindowIndex++;
                replayReadingIndex = 0;

                // Reset activity detector buffer when moving to new window
                // This prevents mixed data from causing incorrect detections during transitions
                if (activityDetector) {
                    activityDetector.reset();
                }

                // Check if we need to preload more windows
                checkPreload();

                // Don't stop based on window count - let elapsed time check handle it
                return;
            }

            // Display current reading
            if (replayReadingIndex < footReadings.length) {
                const footReading = footReadings[replayReadingIndex];
                updateFootDisplay(footReading);
            }

            if (replayReadingIndex < accelReadings.length) {
                const accelReading = accelReadings[replayReadingIndex];
                updateAccelDisplay(accelReading);
            }

            // Display stored activity label from window (instead of running detection)
            // Only update on first reading of each window to avoid flicker
            if (replayReadingIndex === 0) {
                if (currentWindow.label) {
                    // Use stored label from database (ground truth from original recording)
                    updateActivityDisplay(currentWindow.label, 100);
                    console.log('[Replay] Displaying stored label:', currentWindow.label, 'for window at',
                        Math.floor((currentWindow.start_time - replaySessionStartTime) / 1000) + 's');
                } else {
                    // No label stored - show "Unknown" to indicate gap
                    updateActivityDisplay('Unknown', 0);
                    console.log('[Replay] No label stored for window at',
                        Math.floor((currentWindow.start_time - replaySessionStartTime) / 1000) + 's');
                }
            }

            // Update playhead position
            updatePlayhead();

            // Advance to next reading
            replayReadingIndex++;
        }

        // Timeline zoom
        function zoomTimeline(direction) {
            // Implement zoom functionality
            console.log('Zoom:', direction > 0 ? 'in' : 'out');
        }

        // Check if we need to preload more windows
        async function checkPreload() {
            // Calculate how many windows ahead of current position are loaded
            const windowsAhead = replayWindows.length - replayCurrentWindowIndex;

            // If we're within preloadOffset of the end of loaded windows, load more
            if (windowsAhead <= replayPreloadOffset && replayWindows.length < replayTotalWindows) {
                const nextOffset = replayWindows.length;
                console.log(`Preloading windows from offset ${nextOffset}`);
                await loadWindowsBatch(nextOffset);
            }
        }

        // Update playhead position on timeline
        //
        // DEBUG: This function positions the playhead based on elapsed replay time
        // Expected behavior: At 12 seconds of a 24 second session, playhead should be at 50%
        // Actual playhead position is set via: playhead.style.left = `${percentage}%`
        // The percentage is calculated as: (estimatedSeconds / replaySessionDuration) * 100
        function updatePlayhead() {
            if (replaySessionDuration === 0) {
                console.warn('[Playhead] replaySessionDuration is 0, cannot position playhead');
                return;
            }

            // Calculate elapsed time since replay started
            let estimatedSeconds = 0;
            if (replayStartTime) {
                const elapsedMs = Date.now() - replayStartTime;
                estimatedSeconds = Math.floor(elapsedMs / 1000);
                // Cap at session duration
                if (estimatedSeconds > replaySessionDuration) {
                    estimatedSeconds = replaySessionDuration;
                }
            }

            // Calculate position as percentage based on time
            const percentage = (estimatedSeconds / replaySessionDuration) * 100;

            // Debug logging - log every second (when estimatedSeconds changes)
            if (!window.lastLoggedSecond || window.lastLoggedSecond !== estimatedSeconds) {
                console.log('[Playhead] Position:', percentage.toFixed(2) + '%', 'at', estimatedSeconds, 'seconds',
                    '| Calculation:', estimatedSeconds, '/', replaySessionDuration, '=', percentage.toFixed(2) + '%',
                    '| Expected at 50%:', (replaySessionDuration * 0.5).toFixed(1) + 's');
                window.lastLoggedSecond = estimatedSeconds;
            }

            // Update playhead element if it exists
            const playhead = document.getElementById('playhead');
            if (playhead) {
                // Playhead is positioned relative to #timelineScroll container
                // Use percentage-based positioning (0% = start, 100% = end)
                playhead.style.left = `${percentage}%`;

                // Get the actual computed position for verification
                const timelineScroll = document.getElementById('timelineScroll');
                if (timelineScroll && (!window.lastLoggedPlayheadPosition || window.lastLoggedPlayheadPosition !== estimatedSeconds)) {
                    const scrollWidth = timelineScroll.scrollWidth;
                    const expectedPixels = (percentage / 100) * scrollWidth;
                    console.log('[Playhead] DOM updated: style.left =', playhead.style.left,
                        '| Timeline width:', scrollWidth + 'px',
                        '| Expected position:', expectedPixels.toFixed(1) + 'px from left');
                    window.lastLoggedPlayheadPosition = estimatedSeconds;
                }
            } else {
                console.warn('[Playhead] Element not found');
            }

            // Update time display if it exists
            const currentTimeEl = document.getElementById('replayCurrentTime');
            if (currentTimeEl) {
                const minutes = Math.floor(estimatedSeconds / 60);
                const seconds = estimatedSeconds % 60;
                currentTimeEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
        }

        // Simulate receiving sensor data (for testing without actual sensors)
        function simulateSensorData() {
            setInterval(() => {
                if (isRecording) {
                    // Simulate foot data
                    updateFootDisplay({
                        data: {
                            foot: Math.random() > 0.5 ? 'LEFT' : 'RIGHT',
                            values: Array(18).fill(0).map(() => Math.random() * 100),
                            max: Math.random() * 100,
                            avg: Math.random() * 50
                        }
                    });

                    // Simulate accel data
                    updateAccelDisplay({
                        data: {
                            acc: { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2, z: 9.8 + Math.random() },
                            gyro: { x: Math.random() * 10, y: Math.random() * 10, z: Math.random() * 10 },
                            angle: { roll: Math.random() * 10, pitch: Math.random() * 10, yaw: Math.random() * 360 }
                        }
                    });
                }
            }, 100);
        }

        // Uncomment to test without actual sensors:
        // simulateSensorData();
    </script>
</body>

</html>
